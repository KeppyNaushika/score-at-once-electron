// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL") // 例: file:./grading_app.sqlite
}

// ---------------------------------------------------
// ユーザー・組織管理
// ---------------------------------------------------

model User {
  id                String          @id @default(uuid())
  username          String          @unique // 教員のログインIDなど
  passwordHash      String?         // パスワードハッシュ（必要であれば）
  name              String
  role              String          @default("teacher") // "teacher", "admin" などのロールを想定
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  // リレーション
  classesTaught     Class[]         @relation("ClassTeachers") // Corrected: Added relation name
  examsAdministered Exam[]          @relation("ExamScorers")
  scoreRecords      ScoreRecord[]
  examSessions      ExamSession[]
  questionScores    QuestionScore[] // Userが採点した設問スコア
  createdExams      Exam[]          @relation("ExamCreator")
  createdTemplates  ExamTemplate[]
  locks             Lock[]
  projects          Project[]       @relation("UserProjects") // If projects are linked to users
}

model Class {
  id          String    @id @default(uuid())
  name        String    @unique
  grade       Int?      // 学年
  description String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  // リレーション
  students    Student[]
  teachers    User[]    @relation("ClassTeachers") // Corrected: Removed fields and teacherIds, uses relation name
  // teacherIds  String[] // Removed: SQLite does not support primitive lists this way for relations

  @@map("classes") // テーブル名を 'classes' に
}

// ---------------------------------------------------
// 生徒情報
// ---------------------------------------------------

model Student {
  id           String        @id @default(uuid())
  studentId    String        @unique // 学籍番号など
  name         String
  classId      String
  class        Class         @relation(fields: [classId], references: [id])
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  // リレーション
  answerSheets AnswerSheet[] // 生徒が提出した回答用紙
  scoreRecords ScoreRecord[]
}

// ---------------------------------------------------
// 試験・設問・模範解答・テンプレート
// ---------------------------------------------------

model Exam {
  id           String        @id @default(uuid())
  title        String
  description  String?
  examDate     DateTime      @default(now())
  masterImages MasterImage[] // 模範解答の画像パス（複数ページ対応）
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  // リレーション
  questions    Question[]
  answerSheets AnswerSheet[] // この試験の回答用紙
  scores       ScoreRecord[]
  createdBy    User          @relation("ExamCreator", fields: [createdById], references: [id])
  createdById  String
  templates    ExamTemplate[] // この試験のテンプレート
  // 採点者とのリレーション（試験ごとに複数の採点者を設定可能）
  scorers      User[]        @relation("ExamScorers") // Corrected: Removed fields and scorerIds, uses relation name
  // scorerIds    String[] // Removed: SQLite does not support primitive lists this way for relations
  examSessions ExamSession[]
}

// 模範解答の画像パス (複数ページ対応)
model MasterImage {
  id         String   @id @default(uuid())
  examId     String
  exam       Exam     @relation(fields: [examId], references: [id])
  path       String   // 模範解答画像の相対パス
  pageNumber Int      // ページの順番 (例: 1, 2, 3)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([examId, pageNumber]) // 試験内でページ番号はユニーク
}

model Question {
  id             String          @id @default(uuid())
  examId         String
  exam           Exam            @relation(fields: [examId], references: [id])
  questionNumber Int             // 設問番号 (例: 1, 2, 3)
  points         Float           // 配点
  questionType   String          // "multiple_choice", "short_answer", "true_false" など
  correctAnswer  String?         // 模範解答のテキストやマークパターン（JSON文字列など）
  // 採点領域の座標情報 (JSON文字列で表現)
  // 例: { "x": 100, "y": 200, "width": 50, "height": 30, "page": 1 }
  answerArea     String?
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  // リレーション
  questionScores QuestionScore[] // 各生徒のこの設問に対する採点結果
}

// 試験のテンプレート (採点領域の定義セット)
// 複数の教員が共通のテンプレートを使えるようにするため、Examとは別に定義
model ExamTemplate {
  id                String   @id @default(uuid())
  name              String
  description       String?
  examId            String?  // 特定の試験に関連付けられる場合
  exam              Exam?    @relation(fields: [examId], references: [id])
  templateData      Json     // 領域定義、採点基準、画像前処理設定など、JSON形式で保存
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  createdBy         User     @relation(fields: [createdById], references: [id])
  createdById       String
  // 柔軟な小計点/合計点表示領域の定義（JSON形式で保存）
  // 例: [ { "type": "page", "pageNumber": 1, "area": {...}, "scoreFor": "total" }, { "type": "section", "sectionName": "大問1", "area": {...}, "scoreFor": "subtotal" } ]
  scoreDisplayAreas Json?
}

// ---------------------------------------------------
// 生徒の回答と採点結果
// ---------------------------------------------------

model AnswerSheet {
  id                 String          @id @default(uuid())
  examId             String
  exam               Exam            @relation(fields: [examId], references: [id])
  studentId          String?         // 欠席者対応のためNullable
  student            Student?        @relation(fields: [studentId], references: [id])
  pageNumber         Int             // 複数ページ答案のページ番号
  originalImagePath  String          // オリジナルスキャン画像の相対パス
  processedImagePath String?         // 処理済み（傾き補正など）画像の相対パス
  scoredPdfPath      String?         // 最終採点済みPDFの出力相対パス（統合後のPDF）
  isScored           Boolean         @default(false) // 最終統合済みか
  totalScore         Float?          // 最終統合スコア
  isAbsent           Boolean         @default(false) // 欠席者フラグ
  createdAt          DateTime        @default(now())
  updatedAt          DateTime        @updatedAt
  version            Int             @default(1) // 楽観的ロック用バージョン
  // リレーション
  questionScores     QuestionScore[] // 複数の教員のスコアを保持
  examSessionId      String?
  examSession        ExamSession?    @relation(fields: [examSessionId], references: [id])

  // 生徒とページ番号でユニークにする（複数ページ答案の管理）
  @@unique([examId, studentId, pageNumber])
  // 欠席者の場合、studentIdはNULLになるが、その場合のユニーク制約は別途ロジックで管理
}

// 設問ごとの採点結果 (複数教員対応)
model QuestionScore {
  id             String      @id @default(uuid())
  answerSheetId  String
  answerSheet    AnswerSheet @relation(fields: [answerSheetId], references: [id])
  questionId     String
  question       Question    @relation(fields: [questionId], references: [id])
  score          Float?      // 設問ごとの得点
  detectedAnswer String?     // 生徒が認識された回答（OCR結果など）
  isCorrect      Boolean?    // 正誤
  comment        String?     // 採点時のコメント

  scoredByUserId String      // 採点を行った教員のID
  scoredByUser   User        @relation(fields: [scoredByUserId], references: [id])

  status         String      @default("proposed") // "proposed", "final", "disputed", "needs_review"
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt
  scoreVersion   Int         @default(1) // 楽観的ロック用バージョン

  // 各教員が同じ答案の同じ設問を複数回採点できないようにする（再採点時は更新）
  @@unique([answerSheetId, questionId, scoredByUserId])
  // 【重要】一つの答案の、ある設問に対して、"final"なスコアは厳密に一つしか存在できないようにする。
  // statusが"final"のレコードに対してのみ適用され、scoredByUserIdに関わらずユニーク性を強制する。
  // @@unique([answerSheetId, questionId, status], name: "unique_final_score", where: { status: "final" })
  // Prismaのwhere句でのフィルタリングはプレビュー機能のため、コメントアウト。アプリケーション側で制御するか、DBレベルの制約を検討。
  // 代わりに、複合インデックスを作成し、アプリケーションロジックで一意性を保証することを推奨します。
  @@index([answerSheetId, questionId, status])
}

// 生徒ごとの最終的な試験スコアレコード (統合後の結果)
model ScoreRecord {
  id                String   @id @default(uuid())
  studentId         String
  student           Student  @relation(fields: [studentId], references: [id])
  examId            String
  exam              Exam     @relation(fields: [examId], references: [id])
  totalScore        Float
  // その他の集計データ
  excelOutputPath   String?
  pdfOutputPath     String?
  finalizedByUserId String?  // 誰が最終集計を行ったか（統合操作を実行した教員）
  finalizedByUser   User?    @relation(fields: [finalizedByUserId], references: [id])
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@unique([studentId, examId])
}

// ---------------------------------------------------
// 複数教員での同時採点（簡易的な排他制御）
// ---------------------------------------------------

// 採点セッション管理（誰がいつ採点を開始したか、そのPCの識別子など）
model ExamSession {
  id                    String        @id @default(uuid())
  examId                String
  exam                  Exam          @relation(fields: [examId], references: [id])
  userId                String
  user                  User          @relation(fields: [userId], references: [id])
  machineIdentifier     String?       // 採点しているPCのユニークID（簡易的な識別用）
  sessionStartedAt      DateTime      @default(now())
  sessionEndedAt        DateTime?
  // リレーション
  processedAnswerSheets AnswerSheet[] // このセッションで処理された答案
}

// 共有ロックテーブル（簡易的な排他制御のため）
// 例えば、特定のAnswerSheetIdをロックしたい場合に利用
// 主に、クリティカルなDB操作（マイグレーションなど）の排他制御に利用する可能性を考慮。
// 採点ロジックの排他制御は楽観的ロックで行う。
model Lock {
  id               String    @id @default(uuid())
  lockedResourceId String    @unique // ロック対象のリソースID (例: AnswerSheetId)
  resourceType     String    // ロック対象のリソースタイプ (例: "AnswerSheet")
  lockedByUserId   String
  lockedByUser     User      @relation(fields: [lockedByUserId], references: [id])
  lockedAt         DateTime  @default(now())
  expiresAt        DateTime? // ロックの有効期限（自動解除用）

  @@index([lockedResourceId, resourceType])
  @@map("locks") // テーブル名を 'locks' に
}

// プロジェクト管理モデル
model Project {
  projectId   String    @id @default(uuid())
  examName    String
  examDate    DateTime?
  description String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  tags        Tag[]     @relation("ProjectTags")

  // Optional: If projects are created by users
  userId      String?
  user        User?     @relation("UserProjects", fields: [userId], references: [id])
}

model Tag {
  id        String    @id @default(uuid())
  text      String    @unique
  projects  Project[] @relation("ProjectTags")
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
}
